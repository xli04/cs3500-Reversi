How flexible are the interfaces you were given?
    The interfaces that we were given are pretty flexible, since most of the methods they have
given share the same functionality with the current code we have. The methods in the interface is
pretty general and they are all necessary to support the code like placeTurn or pass and get board etc.
For the view,the provider's view is encapsulated pretty well so that we only need to use an adapter pattern to make
sure their view will work properly with our view and controller.

How capable are the views?
    The provider's view is very capable, their view is a recognizable reversi board and updates correctly.
In addition, the methods in their view are also very general. All codes related to repaint board can
be called through the update method, which is completely consistent with our design.

How convenient was it to reuse their code?
    For the controller and view, it is pretty convenient since many methods are sharing the same logic.
For the strategy, we had a some suggestions for some improvements.
-First, in the AvoidCellsNextToCornersStrategy the providers are using position(0,0,0) to represent
 a position with no valid moves. Using a magic number like this makes some sense in that it is
 well documented and works for their existing implementation of the model, 0,0,0 may be valid move
 some time,
 However, It's not about if the (0,0,0) is a valid move, it's about some time their strategy will
 return this real position as a type to represent there is no valid move, since it is an actual point,
 it can be execute by the model, thus this will cause an error.
 -Essentialy, it works pretty good if this strategy does not return (0,0,0), but since the providers
 are using this position as default position, so it may be returned by the method, that is to say, position
 (0,0,0) sometime will represent a position that chosen by strategy or a way to show that the the strategy can
 not find a position to move. However, our coordinator converting method knows nothing about this, so we have
 to add a check before the AvoidCellsNextToCornersStrategy return a position to make sure it will return a valid
 position, rather than a position that seems correctly but actually it is invalid.

How cleanly written and well-documented was their code?
    For the view part, the javadoc is pretty straightforward and clear, we can understand their code easily,
We had a bit of trouble visualizing and clearly understanding how our providers' model worked,
so we would suggest refactoring the  documentation  parts for their coordinator system, for instance
providing an image to show that the points correspond with their coordinators, which is more clear and easier
for the readers to understand. The picture of this in the ReadME was helpful, we just struggled a bit
to know what the difference between a place like (-1, -2, 2) is vs. (2, -1, -2).

If you needed to request changes from them, what were they and why were they needed?
-We noticed  in their key press listener, there is no check for the game is over, so that
even though the game is over and the user can not select a position, the users can still make a pass since
no position needed for make pass. Since there are no actions allowed after game is over, this may
lead to bugs or unexpected actions to occur.
-Some ideas that can be considered for addressing this can be..
 -add a check inside the features so that only if the game is in process, the feature will execute
 the command in to make pass, otherwise the feature will not pass the call back to the controller
  -inside the key listener, add a check to ensure no actions be allowed after game is over.

-We noticed our provider's strategy classes hold an instance of their mutable reversi model interface,
called ReversiModel
-Some ideas to address this are instead providing the strategy classes with a Read Only model interface
This is because if we have a strategy that is needs to query the model, we don’t necessarily want
 our strategy to have full access to the model. This would allow a strategy to be able to call
  mutator methods, like placeCell() or startGame(). There is no reason for the strategy to be
  modifying the model, since this would give the strategy more abilities than it deserves to have.
 If we make this change, even if we pass a mutable model into the strategy class, the strategy class
  only is going to use it as a read only model, so it won’t be able to call the mutators

 -We noticed that the ModelFeatures interface has a method called updateBoard() that
  "Calls the update method on the view that will update the view to have the current state of the
   model".
- Some ideas we had were to try and incorporate more decoupling between the view and model components,
as well as more separation of responsibilities.
One idea with the observer pattern is that the sender class (the model in this case) does not know or
care the type of observer it has. All it knows is that the receiver class (the view in this case) wants
to be notified whenever interesting events occur. The model's interesting events are in when its internal
state is changed (the game is started, a move is made, or a pass is made).
Whenever the model knows it is changed (for example it successfully starts the game or makes a move),
 the model broadcasts to all its listeners that it has been changed. Each listener decides for
  themselves what to do when the model is changed.
  We would suggest making the javadoc more general and not specifically mentioning the view, since
  the model need does not need to know what type of listener it is.
  - With regards to the MVC, we would suggest delegating the job of updating the view to the controller.
  Since we want to maintain single responsibility for components of our system, and the model is already
  handling containing all of the game state information and logic, the responsibility of updating
  the view is more in the wheelhouse of the controller. We could have the controller implement
  model features, this change would allow the control to decide how it wants to update the view
  when the model is updated. This would fit also fit more into the wheelhouse of the controller,
  since the controller's job is to delegate to the model and the view.

