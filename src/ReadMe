--------------------------------------------------HW7-----------------------------------------------------------------
 1. Overview
    The goal of our codebase is to allow games of reversi that follow the rules of Regular Reversi
    to be played between two players. There is no pre-requisite knowledge required beyond
    understanding how to make moves and how to play games of Reversi. Our code is intended for
    extensibility, so that new features, like configurable hotkeys personalized for each player
    can be easily added without changing our code very much. Our components (view, controller,
    and model) are decoupled from implementations as much as model and are dependent on interfaces,
    so any model, view, or controller, or combination thereof, that sticks with our interface
    should be able to work with our game of reversi. This means that our code is designed to support
    future new ways of viewing games of reversi and new ways (for example new rules, new start
    positions, new board sizes, new ways to determine things like score and isGameOver, etc.) of
    modeling games of Reversi.

    Some assumptions that we make in our codebase:
    -Players can be either human players (that will make their move by interacting with our view,
    via command line arguments, GUI buttons, or other mechanisms), or AI Players (that will use
    some form of strategy to select their moves)
    -There can be more than one view and more than one controller for a given game of Reversi.
    One player can be interacting via command line arguments and using a textual view and textual
    controller, while at the same time the other player can be interacting with a GUI and inputting
    their moves by clicking on buttons with mouse events, or using keys or hotkeys on their keybaord,
    for example. In this example, each player would have their own controler and their own view.
    In general, any combination of mechanisms for viewing and controlling a game of reversi can be supported,
    meaning we can have 2 GUI players, 2 textual players, 1 GUI and 1 AI player, 2 AI players,
    etc. etc.
    -AI players will need a controller to prompt them for and apply their moves

 2. Quick Start
A user may get started using our controller codebase by interacting with our a view GUI. Once the
    game is begun, players will be able to interact with the view by selecting a tile for which to
    place their color. When a tile is selected, its display color will become Cyan, indicating
    that this is their selection. Tiles can be unselected and selected by clicking out of bounds,
    or by clicking to other tiles. When a user wants to make move, they can click the enter key
    when they have a selected tile. If the move is valid, it will go through and the corresponding
    internal game logic and external view of the game will be updated, with the selected tile
    being changed to the color of the player who just made the move. If the move is invalid, they
    will know this because the actual color of the selected tile will not be changed to the color
    of the player whose turn it is. What's more there will be a message to notify the user their
    move is invalid. For players interacting with other forms of views, like
    textual views, and we had a game in progress called 'game', a sample user interaction may
    look like this: “game.placeMove(new RowColPair(3,-1), RepresentativeColor.WHITE)"

    If a user wants to make the legal move at (3, -1) in white as described above, by clicking
    on the tile in our GUI view,
    the path of callbacks and delegation will be as follows:
    -ReversiGUIView is listening for low-level events like Key-press. This triggers the low-level
     event of a pressed key
     -The GUI view translates the low level event of the key press from user clicked at
      (3, -1) and press enter into a high level event in that is a request to place a move, as
      outlined in the features interface.
    -The controller will check if the move is valid. Since it is, it will tell its controller manager
    to broadcast the move to all of the controllers that are register / subscribed with the manager
    -The controllers for each player in the game will be managed by the same manager, so each player's controller
    will make the actual move on the model, and then make a callback to the each player's view that is controlled
    by the controller to update itself.
    -The view manager will let the view to update itself, by repainting itself with the updated model.

 3. Key Components
The Manager
 We created an interface to represent a Manager for a model of Reversi. The idea is that the manager
 can notify each type of observer whenever an interesting event occurs on the model, and all of the
 observers of a given type will get called back when an event that they care about occurs. On this
 callback, our controller manager updates the model, and our view callback repaint itself
 on the updated version of the model.
 The key design idea for this assignment is to have two managers: one is for controller and the other is
 for the view. Once an interesting event occurs (a move is made by a player, the game is started, etc.), all of
 the controllers and views that care about this model will be notified and they will be updated.

The controller
 Represents an asynchronous controller for a game of reversi. Controllers are event-driven and
 respond to whatever event happens at a given time. The job of controllers are to control the
 flow of Reversi Games by determining when and how to update the model, as well as how and when to
 update the GUI view that they use.

KeyBoard And Mouse Lock
 Once the players in this game is one human player and one Ai player, our controller will let the view and
 HexGrid to lock the key board and mouse events for the ai player, so that the human player can not mark
 a cell as selected nor actual make an action for ai player. This will prevent the human player from
 bothering the ai player.

Start Game and List<Manager> in the model
 Since there should be a clear distinction between “setting everything up” and “actually playing the game”.
 our view and controller can paint the board before the game started. the start game method will first set the
 player who will place first to black and notify all the views and controllers that the game is started, the
 message related to the game state like the current turn, current score.etc will be shown and the player can
 start to place the cell on the board.

MockView
 We have a MockView in the view package that used for test only, Since we only want to test if the view interact
 with other components correctly as we expected, it will only take a view manager and a string builder as the
 parameter, since we don't want the view actually draw the stuffs when we test it. The StringBuilder is used to
 help us determine if the view interact with the other components as we expected. For example, if the one of the
 play took an action, the controller will call the view to let it toggle the turn, at this time, we will add a
 message "You have toggle the turn to the given color" to show that the view interact with our controller correctly.

***Hint Button***
 We add a hint button in to our north panel, the logic of this hint button is first we will find all the position
 that can make a move with the current player's color and store the position and the cell that placing here can
 flip as a Map<RowColPair, Integer>, then we will based on this position and integers to draw a number on that position
 means the cells that can be flipped if you place here. If the player click the button, controller will show
 show the hints for the players, and if they click the button again, the controller will let the view hide the hints.
 What' more, the show hints or not is independent for each players, that is, if the black player choose to show
 the hints, the controller will not show the hints for white player and the view will not show the show the hints for
 players if this is not their turn. The painting logic for the hints is, we will drawing the number on the
 cell that can make a valid move, since this hint will only be drawn on an empty cell, that for sure, we don't need to
 worry about the number was covered by the black circle, which used to mark this cell as been occupied by black player.

 4. Key Subcomponents

 For the view manager, whenever the model is updated, the view manager will notify all the views that
 observe the model to repaint the board in order for each player to have an updated view of the board.

 For the controllers manager, controllers that update the model will be notified to update the game state.
 Updating the game state includes...
 -Updating the current score for the black and white players
 -Updating whose turn it
 -Updating whether the player who will play in the  next turn is a human player or not
 -Checking if there are no valid move on the board, and if this is the case,
  notifying the model that the player that must pass (since they have no valid moves) .
 -Checking if the player who will play in next turn is an Ai player, and if this is the case, asking the player
 to choose for the position and place it.

 For the model status, we have four values to represent the current status for the game
 END = The game has ended by 2 consecutive passes.
 InProgress = the game has started and there are still legal moves on the board (at least
 one legal move for black or for white).
 HasNotStarted = startGame() has not been called yet.
 Blocked = no valid moves, but the game is not over yet since the game has no passed.

 For the players, we have two classes to represent two different kinds of players, human player and Ai player
 and they share a common player interface which contains a very important methods isAiPlayer() this is used to
 ask the player to choose for the next move if it is an ai player since human player will interact with the view
 and press keys to place move and make pass.

 Model Status: we have A ReversiModelStatus class represents the current status for the game model, once the player
 placed a move or made a pass or the start the game, the status of the game will be updated in order to reflect the
 most recent status. so that in the controller, we will also take in a model status as the parameter in order to track
 the status of the model more effectively. we initialize the status to hasNotStart since every time when start the game,
 the status will be updated and also, players can not place move or make pass before the game was started.


5. Source Organization
    -In the src directory, we can find 3 packages
      -Model → This package contains the interface and domain logic relative to the rules of Reversi
        games, as well as other structures that our reversi models use to represent different features
        of the game. For instance, our model holds the Direction class that is used to handle checking
        if moves exist and executing moves on a certain direction.  This package also contains a Mock
        model. This mock model is used to confirm that strategies are using the proper inputs in
        order to check moves.
      -Controller→ contains different classes that help run the brains of our reversi game.
      We have a Controller class that represents an event-driven asynchronous GUI Controller.
      The Controller serves to control the flow of Reversi Games by determining when and how to
      update the model, as well as how and when to update the GUI view that they use.
       We have a manager interface, which represents a Manager for a model of Reversi. Managers
       represent a type of observer, and the manager notifies all observers of the given type
        whenever an interesting event occurs on the model.observers of a given type can be updated
         when an event that they care about occurs. We have a manager for our controller and
         that
      -View → contains different classes that help display our game to the players. The view provides
        interfaces for players to specify their desired move, and to observe the state of the game at
        any time. The view also contains the view manager class, which raises events to all the views
         that it manages. Views can subsrcibe to be managed by this manager. Whenever the game state
          is updated, the view manager is called-back, and it notifies all its view subscribers to update their display.
      -Strategy -> contains different classes that help a player select a move, by using a specific
      strategy. The strategy package outlines how we can compose strategies, as well as contains
      specific implementations for different fallible and infallible strategies.
      -Test: in the test directory, we may find a few packages:
          Model, controller, and view packages:
              Contains tests for components and their respective subcomponents whose package-visible
              functionality that isn’t part of their public interfaces
          (no package) / the default package:
              Contains tests for the publicly visible signatures of our public interfaces
              This will be the home for unit tests for individual components as well as integration
              tests to measure communication between components (e.g. Between the view and controller)
              Also Contains tests for our strategies, to see if they do in fact consider the values
              of different moves and uphold their class signatures. For example, our fallible classes
              should throw an exception when their strategy move type does not exist for a given
              board state.

Changes for part 3:
 We added a start game method in our model in order to make a clear distinction between “setting everything up”
 and “actually playing the game”. In this method, we assigned the color for players by player that join the game
 first will placing for black cell and player that second join the game will placing for white cell, and set the
 player who goes first to black, and notify the controllers and views that care about this model that the game is started.

 Also, we modify the constructors to take a list of managers as parameter so, once the game was started, all the
 stuffs that care about the model will be called to be updated. it also ensures that there is a clear distinction
 between “setting everything up” and “actually playing the game”. because we think the user should never add another
 controller during the game, all the managers should be settled before the initialization of the game.


--------------------------------------------------HW6----------------------------------------------------------------------------------------------------
1. Overview
The way we generate the view is by first get the coordinators for the middle point, which is (0,0)
    other point will make modifications based on the difference between their coordinators to (0,0)
    and if the cell was occupied(the color of the cell is black or white), view will fill a circle
    based the coordinators of the topping point to show the player already placed a cell in here.
    Essentially, the CubeCoordinateTrio system involves getting coordinates relative to the
    origin point (0,0), which is in the middle tile of any Reversi Board.

    It is assumed that each player in the game has a specific goal in mind with choosing where to place
    their tiles if they are not going to pass on their next turn. Strategies are designed to suggest
    the best move based on a specific goal that a player may have in mind. Strategies can be used
    by any player in the reversi game, whether they are an AI player or a human player.

The key design idea of the view is we have a hexgrid class, which represent a drawing and view only board,
    we have two board, one is the model itself and another is the hexgrid class, the idea of this design
    is if the user selecting a color, we will only mark that cell in the drawing board instead of
    change it in the model since it's unnecessary to do so and may mess up the model by introducing a
    new color type.

The logic of selecting and deselecting cell is using the polygon. everytime when user interact with
    the window, we will take record of the position that was clicked and convert it to the coordinator
    system that (0,0) is in the middle. Next, we will try to find if this point is inside of a hexagon
    if it is, get the coordinator of that hexagon. The the selected position will be marked to Cyan in
    the drawing board. The view will let the user deselect a selected cell by (1) clicking on the
    current selected position again (2) clicking on another valid position new or (3) can not
    selecting a position. If the selecting position is not null and if the user typed ENTER,
    we will try to place a cell in the current selected position. If the user typed SPACE, that
    means the current user choose to pass in current round. The user can npt marked an occupied
    cell since we think it's meaningless to do so and it may mess up the drawing board.


2. Quick Start
    A user may get started using our view codebase by interacting with our View's GUI. Once the
    game is begun, players will be able to interact with the GUI by selecting a tile for which to
    place their color. When a tile is selected, its display color will become Cyan, indicating
    that this is their selection. Tiles can be unselected and selected by clicking out of bounds,
    or by clicking to other tiles. When a user wants to make move, they can click the enter key
    when they have a selected tile. If the move is valid, it will go through and the corresponding
    internal game logic and external view of the game will be updated, with the selected tile
    being changed to the color of the player who just made the move. If the move is invalid, they
    will know this because the actual color of the selected tile will not be changed to the color
    of the player whose turn it is. For players interacting with other forms of views, like
    textual views, and we had a game in progress called 'game', a sample user interaction may
    look like this: “game.placeMove(new RowColPair(3,-1), RepresentativeColor.WHITE)"

3. Key Components
     HexGrid
     The key design idea of the view is we have a HexGrid class that only used to show the graph and get
the selected points. Because rather than make changes on the model directly, doing so can keep
players from cheating effectively. The logic of the game process in the view is:
display the current game state, if the user choose a position, rather than change the color of
this cell in the actual model, only change the color in the display. This design keeps users
from  cheating, since only valid moves requests are actually send to be made on the model.
If the player want to place a cell there and it is a valid move, the view will be updated to
the new game state when the model is updated.

    ReversiView, View interface and Features
    Our Reversiview are classified as either GUIViews, or TextualViews. We have an interface describing
each. GUIViews are views that are interacted on via button clicks, keyboard presses, etc. and
are flexible to take in different methods of input, like mouse presses.Even though
each view gets its input via low-level events, there is always the possibility of future
view implementations adding more inputs, like hotkeys and keybaord commands. Because of this
variety, we used a Features Interface in order to translate these low-level events into actions
that can be taken care of in the Controller. This allows our controllers to be decoupled from
views, and be able to be flexibile with any view implementations, whether they are textual or GUI
based. This also allows the controller to not be closely tied to a specific library - like Java
Swing, which is good for future extension and separating the roles of the View and Controller
from each other.

    ReversiBoardPanel
    ReversiBoardPanel is used to draw the hexagon board in the window only, it also has the functionality
to resize the window and to convert the screen coordinators to board coordinator (which means (0,0) is in
the middle). It also be responsible be handle the user's click by using the Point2D class to capture the
position that user clicked then convert it to board coordinators to see if it matched with any hexagons.

    Strategies
    In order to represent our strategies, we used 2 interfaces: InfallibleStrategy, and
FallibleStrategy. Each different strategic approach that we used is either a fallible, or an
infallible strategy. For shared logic between concrete strategy implementations, we used an
abstract class called AbstractStrategy. Abstract Strategy represents a strategy for a game of
reversi. Abstract strategies are exclusively fallible strategies (strategies that may or may not
return a move for a given model), or  infallible strategies (strategies that are guaranteed
to return a move for a given model). Strategies serve to help players to decide where to place
their next move during a game of Reversi.

    In order to combine strategies together, we have a CompositeStrategy class. A Composite
Strategy represents a comprehensive strategy that is composed of two components: two strategies.
Composite strategies default to trying their first input strategies as their first option. If that
strategy finds a move to make, this strategy selects that move. Otherwise, the strategy will use its
second strategy as a backup. Due to this, Composite strategies can be composed of one single strategy
with other composite strategies, allowing for flexible and advanced strategies to be created.

    Since all the strategies have a chance to fail, we have a CompleteStrategy class which is a
    concrete implementer of our InfallibleStrategy interface. The InfallibleStrategy interface
    promises its strategy will always return a position to move to for a game of reversi, as long
    as the game is a legal, in-progress game. If the game is not legal or not in-progress, this
    is the only case where InfallibleStrategies may be unable to return a valid position for a move.
    In this case, our complete strategy throws an IllegalStateException to indicate that the reversi
    model is not in a legal state for play.

    MockModel
    We have a MockModel in the model package that used for test only, it will take a regular
model and the appendable and a list of RowColPair used to determine whether we will lie to the strategy
as the parameter, so that if the strategy used the method in the mock model it will not only have
the functionality that regular model has by using the delegate, but also it can add a string message
to the string builder to let us know which pair does the strategy visited and also to test the strategy
itself works properly. For example, for our CornerStrategy, the desired behavior is that only moves to
the corners are checked, and moves to any other positions are not considered. We can leverage our
MockModel in order to see that when our strategy is trying to choose its move, it calls
the checkMove() method of the model interface that it is passed. The arguments of the method are appended
to our appendable log, and then in our tests we can check the values added to our log to see what moves
were checked and which moves were not checked. If we choose to lie to our strategy, which means the lie list
is not empty and when the strategy is checking move for a specific position in the lying list, the mock
model will lie to the strategy that there is no valid move in given position, and append "lie to you"
to the stringBuilder.


4. Key Subcomponents
-Move Class: A move Represents an evaluation of a board state for a player for a game of Reversi.
 A move can be expressed as a coordinate on the board onto which a player could place their tile,
 WITH an evaluation of how beneficial the move is to the player that makes it, or simply as an
 evaluation of how beneficial a given board state is.

***Minimax***: the idea of the minimax is in our turn, we want the move that can gives us the maximum value and
    there will also be a simulate player for our opponent that will play the move that gives us the
    minimum value. it selects the move that would give us the best outcome against an opponent using
    the same algorithm and evaluation heuristic. MeanWhile, the minimax is an exhaustive search technique,
    thus it is better to restrict its depth, which means the round we are going to simulate.
  max       15
          /    \
  min    5      15
        / \    /  \
  max  5   7  15  18
      / \ / \ / \  / \
  min 3 5 6 7 1 15 2 18
  _______________________
   The game tree represents all possible moves and their consequences. Each level of the tree alternates
   between the two players. The root of the tree is the current game state, and each level below it
   represents the possible moves of the players. one player is the "maximizer," who tries to maximize
   their own score (e.g., win the game), and the other player is the "minimizer," who tries to minimize
   the maximizer's score (e.g., prevent the maximizer from winning).Once the tree is traversed up to the
   root, the maximizer chooses the child node with the highest value, which represents the best move for
   them. The minimizer, in turn, chooses the child node with the lowest value.
  A very straightforward example is showing above, the row we choose the max value means is our turn and
  otherwise, it's opponent turn.
  After we simulate the game to the certain depth, and we read the result from bottom to top. in the root,
  it means the possible score we can get in this movement.

***AlphaBeta***: alphabeta strategy is a advanced minimax strategy since it applied puring on the
    minimax. Alpha-beta pruning works by maintaining two values, alpha and beta, which represent
    the minimum score that the maximizing player is assured of and the maximum score that the
    minimizing player is assured of, respectively. As the search progresses, nodes are pruned
    (i.e., not evaluated further) if it is determined that they cannot lead to a better outcome than
    the current best option. This is achieved by comparing the node's evaluation with the alpha and beta values.

Features: The features interface contains two methods that may modified the model, place move
    and make pass.

Strategies: Since it's not a good idea to return a null when there is no valid move to place, our
    design idea in the controller will be if there is no valid move for current user, the controller
    will notify the user they can only make pass and reject all the other command except pass. Under
    this circumstance, our strategies will not failed, thus if the strategies can not find a valid
    position to place cell, we will print a message to let us know something wrong with the strategy

In the strategy-transcript.tx, it containing a transcript from our mocked model of the captureMaxPieces strategy
    choosing a move for Black on the starting board configuration. with the following code, since the
    captureMaxPieces strategy will go over all the position in the board to try to find a valid move, our
    stringbuilder will contains the all the position, and since in the initial all the valid position can
    only flip one cells, the strategy will choose the upper-most left-most one. And since we choose not to lie
    to the strategy, it will choose the position as usual.
        StringBuilder builder = new StringBuilder();
        MockModel mock = new MockModel(model, builder, new ArrayList<>());
        InfallibleStrategy strategy = new CompleteStrategy(new CaptureMaxPieces());
        RowColPair pair = strategy.choosePosition(mock, RepresentativeColor.BLACK);
        System.out.println(new ReversiTextualView(model));
        mock.placeMove(pair, RepresentativeColor.BLACK);
        System.out.println(builder.toString());
        System.out.println(new ReversiTextualView(model));

Corners: Our board has 6 corners, since there are six places can guarantee the cell will not be flipped
    after iw was placed, as the graph shows below
             1 _ _ _ _ 6
            _ _ _ _ _ _ _
           _ _ _ _ _ _ _ _
          _ _ _ _ _ _ _ _ _
         _ _ _ _ X O _ _ _ _
        2 _ _ _ O _ X _ _ _ 5
         _ _ _ _ X O _ _ _ _
          _ _ _ _ _ _ _ _ _
           _ _ _ _ _ _ _ _
            _ _ _ _ _ _ _
             3 _ _ _ _ 4


Model setup:
    The ability to create a board of a given size, in default initial state.(Constructor)
    The ability to create a copy of a board.(getBoard())
Observations:
    How big is the board?(getSize())
    What are the contents of a cell at a given coordinate?(getColorAt())
    Is it legal for the current player to play at a given coordinate?(checkMove())
    What is the current score for either player?(getScore())
    Does the current player have any legal moves?(hasToPass())
    Is the game over?(isGameOver())
Operations:
    The current player makes a move at a given cell(placeMove())
    The current player passes(makePass())

5. Source Organziation
  -In the src directory, we can find 3 packages
    -Model → This package contains the interface and domain logic relative to the rules of Reversi
      games, as well as other structures that our reversi models use to represent different features
      of the game. For instance, our model holds the Direction class that is used to handle checking
      if moves exist and executing moves on a certain direction.  This package also contains a Mock
      model. This mock model is used to confirm that strategies are using the proper inputs in
      order to check moves.
    -Controller→ contains different classes that help run the brains of our reversi game. The
       controller handles, adding the players, and coordinating player input with
       visual output to ensure that each move affects the underlying model and those changes are
       reflected in the view. Currently only have one class used to test.
    -View → contains different classes that help display our game to the players. The view provides
      interfaces for players to specify their desired move, and to observe the state of the game at
      any time.
    -Strategy -> contains different classes that help a player select a move, by using a specific
    strategy. The strategy package outlines how we can compose strategies, as well as contains
    specific implementations for different fallible and infallible strategies.
    -Test: in the test directory, we may find a few packages:
        Model, controller, and view packages:
            Contains tests for components and their respective subcomponents whose package-visible
            functionality that isn’t part of their public interfaces
        (no package) / the default package:
            Contains tests for the publicly visible signatures of our public interfaces
            This will be the home for unit tests for individual components as well as integration
            tests to measure communication between components (e.g. Between the view and controller)
            Also Contains tests for our strategies, to see if they do in fact consider the values
            of different moves and uphold their class signatures. For example, our fallible classes
            should throw an exception when their strategy move type does not exist for a given
            board state.

Changes for part 2:
    in the previous homework, our model do not the the ability to get current score for either player,
    because in the previous homework, we only used this kind of method as a helper method to determine
    the winner of the game when the game is over. so, we added a method called getScore() in the readOnly
    model, and it takes a color as parameter. The way we implement that is by counting the number of
    the cell in given color in the board.

    we added a new method called getDeepCopy() in the readOnlyReversi, because in the
    Minimax strategy, we need to create a new model to test the overall impact that brought by placing
    in the different position, it certainly can not make modification on the model, so that we added
    this method to help us implement the Minimax strategy.

    -Refactored package private constructor to also take into account the turn of the rigged board.
    -Refactored our deep copy to use our package private constructor for copies,
     this way deep copy remembers whose turn it is.

    -Changed hashcode() to use Objects.hash() instead of adding row and col to reduce collisions
    -Changed name of CubeCoordinatePiar to CubeCoordinateTrio, added javadoc to it
    -Documented more invariants that we had in our RegularReversiModel







--------------------------------------------------HW5----------------------------------------------------------------------------------------

1. Overview
This code base is designed to simulate games of reversi between players. The general
    ReversiModel 2-layer interface can be implemented to create custom games of reverse. Users of
    the program do not need to be familiar with Java libraries or require any prerequisite
    knowledge beyond that needed to give input to the view implementation of the program.
    How to play: Reversi games may come in multiple flavors in the future, but to play a regular
    reversi game, here are the general rules (not all rules are included): There are 2 players,
    each gets assigned a color. The game is started in an initial starting position, which may
    contain pre-placed tiles on the board. Each player takes turns placing disks of their color on a
    hexagonal board. Players alternate turns. Moves can only be made to unoccupied tiles, and
    players cannot override other players’ turns. The game ends after each player passes, whether by
    choice or due to having no more valid moves to make. Moves must be made adjacent to
    already-placed tiles.

    -Design choice: we decide to let the model to handle the turn, because the turn should be the rules of the game
    thus means the integrity-of-the-game-rules question. For the game over, the only way that to determine if the game
    is over is if two players pass in a same row, so our model will notify the user they can only pass in this time
    rather make the pass action for users. For example, if there is no valid move in the board, the game will not over
    automatically, the controller will let the users know they can only choose to pass in this time and after two user
    choose to pass, the game is over.

2. quickStart
    A user might make a move in a regular reversi game by specifying a specific location to place
    their move and their disc color to be placed at this location. For example, if we had a model
    called “game”, a move could be made by executing the command:
    “game.placeMove(new RowColPair(0,0), CellColor.BLACK).” This command places a black tile at
    the position in the board at (0,0), assuming it is a valid move, and the game is not over yet.

3. key component
a. For the board, Our game uses cube coordinate system, we choose to use the map to represent
    the hexagon board, each cube system has three coordinators r,q and s, as the graph shows below, and the middle
    point is (0,0,0), the graph shows the coordinators with the order(r,q,s), as the graph shows, row means the
    horizontal line, the q means the leftCol which refers to the number of column we count from
    left to right and the s means rightCol means the number of column from right to left.
    the original point is in the middle of the graph, if the cell go left, the r will increase,
    if the cell go right, the r will decrease. for the q, the leftCol, it will increase when
    the col go left. and for the s, the rightCol, it will increase when the col go right.

           (-2,0,2) (-2,1,1) (-2,2,0)
      (-1,-1,2) (-1,0,1) (-1,1,0) (-1,-2,-1)
    (0,-2,2) (0,-1,1) (0,0,0) (0,1,-1) (0,2,-2)
        (1,-2,1) (1,-1,0) (1,0,-1) (1,1,-2)
          (2,-2,0) (2,-1,-1) (2,0,-2)
            _ _ _
           _ X O _
          _ O _ X _
           _ X O _
            _ _ _
    (After initialize the board with size 3)
             X O
            O _ X
             X O
   (board with size 2 after initialization)

  Another coordinator system only have two coordinators, the row and col used to represent the cell on the board
  we use r to represent the row and q to represent the col. since our column is counting from left to right,
  s is used to track the adjacent hexagon for current from different directions, so we don't add
  it to the rowCol system.
  For the direction, the left cell for (0,0,0) is (0,-1,1), right cell for (0,0,0) is (0,1,-1),
  LeftUp cell for(0,0,0) is (-1,0,1), LeftDown cell for (0,0,0) is (1,-1,0), RightUp cell for (0,0,0) is (-1,1,0),
  RightDown cell for (0,0,0) is (1,0,-1).
  For the pre-positioned cells, the middle of the board will be empty and the pre-positioned cells will be surround
  its. 2 should be the smallest board size to start since 1 can not contains all the pre-positioned cells. User
  interact with rowCol pair, because it's more user-friendly.



b.TileColor system: 3 pronged enum: NONE, WHITE, BLACK

c.All cells are initialized to COLOR NONE

d.After the game has been started, any NONE-colored tiles represent empty tiles

e.In the hasToPass method, it will return a boolean value, our model will not be responsible for make the pass for
    users, but it will notify the users they can only do pass at this time. And in the controller, if the hasToPass
    returns true, no other command except pass will be accepted.

f.Check move return a map to record the number of the cell that can be flipped in a certain direction, because the
    order of directions returned by directions.values will not change, we can use it directly with the for loop to
    go through all the directions

g. For the logic, the basic logic for the implementation is there are six directions to determine the adjacent
    position to the current, and if there is a cell with opposite representativeColor with current representativeColor
    in these six positions, keep tracking of that position to check if it forms a line in that direction that contains
    number of cell in opposite representativeColor and one cell with the same representativeColor. if there exist such
    direction, it means this is a valid move and flip the cell in this direction. And if there is no such valid move
    for the given representativeColor in the whole board, the user has to pass, and if two users pass in a same round,
    the game is over.

h. class Invariant
    1.passTimes can not be larger than 2, the constructor initialize the passTimes to 0, and every time
     it will plus one, once the passTimes greater than 2, the game is over.
    2.size is positive, the default size is 6, and if the size user entered is less than 1, it will throw
    exception
    3.turn can only be white or black, turn was initialized to Black, and every time when a user finished a
    move or pass, the turn will alter to its opposite, where black's opposite is white and white's opposite is black.

i. our place move and make pass method will take a color as parameter in order to make sure the users can only place
   the cell when it's their turns

4. Key subcomponents
   -We use a Direction data type to compute adjacent cells. Essentially, a given cell on our board
       has neighbors from 6 directions (left, right, left-up, right-up, left-down, right-down). In
       order to handle moves and to flip tiles when sandwiches are created, a search is done in each
       direction to determine which tiles can be flipped, if any exist.
   -We use a rigged start with our package-private testing constructor.
      It is used for testing purposes where we can start the game from an initial board position,
      even if it is not necessarily a possible position by game logic. By being able to rig both
      legal and illegal positions, we can ensure that our model handles exceptional and regular
      circumstances gracefully.

5.Source organization
    -In the src directory, we can find 3 packages
    -Model → This package contains the interface and domain logic relative to the rules of Reversi
      games, as well as other structures that our reversi models use to represent different features
      of the game. For instance, our model holds the Direction class that is used to handle checking
      if moves exist and executing moves on a certain direction.
    -Controller→ contains different classes that help run the brains of our reversi game. The
       controller handles, adding the players, and coordinating player input with
       visual output to ensure that each move affects the underlying model and those changes are
       reflected in the view. Currently only have one class used to test.
    -View → contains different classes that help display our game to the players. The view provides
      interfaces for players to specify their desired move, and to observe the state of the game at
      any time.
    -Test: in the test directory, we may find a few packages:
        Model, controller, and view packages:
            Contains tests for components and their respective subcomponents whose package-visible
            functionality that isn’t part of their public interfaces
        (no package) / the default package:
            Contains tests for the publicly visible signatures of our public interfaces
            This will be the home for unit tests for individual components as well as integration
            tests to measure communication between components (e.g. Between the view and controller)